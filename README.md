# Mochi

Mochi is the teaching companion app for our Flutter curriculum. The codebase is structured to highlight key concepts—widgets, styling, state management, asynchronous work, and more—so learners can trace each lesson directly into the source.

## Cross-Platform vs. Native Development

| Topic | Cross-Platform (Flutter) | Native (Kotlin/Swift) |
| --- | --- | --- |
| **Codebase** | Single Dart codebase compiled for Android, iOS, web, and desktop. | Separate projects per platform, typically Kotlin/Java for Android and Swift/Objective-C for iOS. |
| **UI Consistency** | Flutter renders widgets with its own engine, ensuring a uniform look across platforms. | Relies on platform-native UI kits (Jetpack Compose, UIKit/SwiftUI), so parity must be maintained manually. |
| **Performance** | Near-native due to ahead-of-time compilation and Skia rendering; performance tuning focuses on widget build cost. | Native APIs offer full access to platform tooling and optimizations with minimal abstraction overhead. |
| **Team Skills** | Dart/Flutter knowledge scales across platforms; designers and developers share widget libraries. | Requires platform-specific expertise; features may ship on different timelines per platform. |
| **Ecosystem** | Strong community packages, plus platform channels for native integrations when needed. | Direct access to the latest platform features, but code reuse across platforms is minimal. |

## Environment Setup

Follow these steps to get your development machine ready for the curriculum:

### 1. Install the Flutter SDK

1. Download the latest stable SDK from [flutter.dev](https://docs.flutter.dev/get-started/install).
2. Extract it to a permanent location (e.g., `~/development/flutter`).
3. Add Flutter to your `PATH`:
   - macOS/Linux: add `export PATH="$PATH:/path-to-flutter/bin"` to your shell profile.
   - Windows: update **Environment Variables → Path** with `C:\\src\\flutter\\bin`.
4. Run `flutter doctor` to verify your setup; address any issues Flutter reports.

### 2. Android Studio (Android Toolchain)

1. Install [Android Studio](https://developer.android.com/studio) and launch it once.
2. From the **More Actions → SDK Manager**, install:
   - **Android SDK Platform** for the latest stable API level.
   - **Android SDK Build-Tools**.
   - **Android Virtual Device (AVD)** images if you plan to use the emulator.
3. Accept all Android licenses by running `flutter doctor --android-licenses`.
4. (Optional) Create an AVD via **Device Manager** for quick testing.

### 3. Visual Studio Code (Lightweight Editor)

1. Install [VS Code](https://code.visualstudio.com/).
2. Add the official **Flutter** and **Dart** extensions from the marketplace.
3. Open this repository in VS Code and trigger the **Flutter: Run Flutter Doctor** command to confirm that the editor detects your SDK.
4. Configure preferred formatters or analysis options via `.vscode/settings.json` (create the file if needed) to share editor tooling across the team.

### 4. Additional Tips

- Keep the Flutter SDK channel pinned to **stable** for classroom consistency.
- If you work on iOS, install Xcode and run it once to initialize command-line tools (`xcode-select --install`).
- Install `fvm` (Flutter Version Manager) if you need to juggle multiple SDK versions for advanced lessons.

## Project Structure

```
.
├── lib/
│   ├── main.dart             # App entry point with curriculum examples.
│   └── package.intl/         # Local shim for the intl package (lesson-specific).
├── test/                     # Unit/widget tests (extend per lesson).
├── android/, ios/, web/      # Platform shells generated by Flutter.
├── linux/, macos/, windows/  # Desktop embeddings.
├── pubspec.yaml              # Dependencies and asset registration.
└── analysis_options.yaml     # Lints aligned with the course.
```

Use `lib/` as the canonical place for new lesson modules. The Flutter UI now follows an MVC-inspired layout with `lib/views/` housing widgets and screens, and `lib/controllers/` containing Riverpod state controllers. Additional folders such as `lib/services/` can be introduced in later lessons when topics require them.

## Curriculum Map

This guide connects each topic in the syllabus to the corresponding code so learners can explore the implementation while studying the theory.

### Widgets & Layout
- `lib/main.dart` → `MochiApp`, `MochiHomeView`, and `DailyDetailsCard` demonstrate stateless/stateful compositions, Scaffold layout, and custom widget building.
- Explore the `TableCalendar` widget configuration to see third-party widget integration and builder callbacks.

### Navigation & Routing
- `lib/main.dart` registers named routes (`MochiHomeView.routeName`, `DemoMenuView.routeName`, and `NavigationDemoView.routeName`) and wires `onGenerateRoute` so detail pages can decode typed arguments.
- `lib/views/screens/navigation_demo_view.dart` provides two flows: one uses `Navigator.push` with a constructor argument, the other uses `Navigator.pushNamed` with a `NamedRouteDetailsArgs` payload. Both routes call `Navigator.pop` with a string result that surfaces back in the parent UI.

### State Management (Riverpod)
- `JournalController` and related providers (`journalControllerProvider`, `selectedDateProvider`, `isSavingProvider`) show how global state flows through Riverpod.
- Look at the `ConsumerWidget` implementations to understand how widgets read and react to provider changes.

### Theming & Styling
- Theme definitions inside `MochiApp` illustrate global typography with `GoogleFonts` and custom color palettes.
- `DailyDetailsCard` demonstrates component-level styling via `BoxDecoration`, `ChoiceChip`, and custom buttons.

### Asynchronous Work & Networking Preparation
- The `onPressed` handler in `DailyDetailsCard` simulates a network request with `Future.delayed` while toggling the `isSavingProvider`. Replace this stub with real API calls once you introduce networking.
- When you add HTTP lessons, place API clients under a new `lib/services/` directory and inject them into Riverpod providers for testability.

### Data Modeling & Serialization
- The `Mood` enum and the `Map<DateTime, Mood?>` state highlight simple model definitions. Extend this map with richer data classes (`@immutable` models or `freezed` classes) in advanced modules.

### Testing
- Scaffold new widget and provider tests under `test/`. Start with Riverpod provider tests to reinforce reactive state principles, then add widget tests for UI expectations.

## Additional Resources

- [Flutter documentation](https://docs.flutter.dev/) – canonical reference for widgets, tooling, and best practices.
- [Riverpod documentation](https://riverpod.dev/) – deeper dives into providers and scoped state patterns.
- [Flutter Favorite packages](https://pub.dev/flutter/favorites) – curated list of community packages worth exploring after core lessons.
